package model

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *BaseTickData) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 15 {
		err = msgp.ArrayError{Wanted: 15, Got: zb0001}
		return
	}
	z.PriceChange, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "PriceChange")
		return
	}
	z.PriceChangePercent, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "PriceChangePercent")
		return
	}
	z.LastPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "LastPrice")
		return
	}
	z.CloseQty, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "CloseQty")
		return
	}
	z.BidPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "BidPrice")
		return
	}
	z.BidQty, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "BidQty")
		return
	}
	z.AskPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "AskPrice")
		return
	}
	z.AskQty, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "AskQty")
		return
	}
	z.OpenPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "OpenPrice")
		return
	}
	z.HighPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "HighPrice")
		return
	}
	z.LowPrice, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "LowPrice")
		return
	}
	z.BaseVolume, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "BaseVolume")
		return
	}
	z.QuoteVolume, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "QuoteVolume")
		return
	}
	z.OpenTime, err = dc.ReadInt64()
	if err != nil {
		err = msgp.WrapError(err, "OpenTime")
		return
	}
	z.CloseTime, err = dc.ReadInt64()
	if err != nil {
		err = msgp.WrapError(err, "CloseTime")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BaseTickData) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 15
	err = en.Append(0x9f)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.PriceChange)
	if err != nil {
		err = msgp.WrapError(err, "PriceChange")
		return
	}
	err = en.WriteFloat64(z.PriceChangePercent)
	if err != nil {
		err = msgp.WrapError(err, "PriceChangePercent")
		return
	}
	err = en.WriteFloat64(z.LastPrice)
	if err != nil {
		err = msgp.WrapError(err, "LastPrice")
		return
	}
	err = en.WriteFloat64(z.CloseQty)
	if err != nil {
		err = msgp.WrapError(err, "CloseQty")
		return
	}
	err = en.WriteFloat64(z.BidPrice)
	if err != nil {
		err = msgp.WrapError(err, "BidPrice")
		return
	}
	err = en.WriteFloat64(z.BidQty)
	if err != nil {
		err = msgp.WrapError(err, "BidQty")
		return
	}
	err = en.WriteFloat64(z.AskPrice)
	if err != nil {
		err = msgp.WrapError(err, "AskPrice")
		return
	}
	err = en.WriteFloat64(z.AskQty)
	if err != nil {
		err = msgp.WrapError(err, "AskQty")
		return
	}
	err = en.WriteFloat64(z.OpenPrice)
	if err != nil {
		err = msgp.WrapError(err, "OpenPrice")
		return
	}
	err = en.WriteFloat64(z.HighPrice)
	if err != nil {
		err = msgp.WrapError(err, "HighPrice")
		return
	}
	err = en.WriteFloat64(z.LowPrice)
	if err != nil {
		err = msgp.WrapError(err, "LowPrice")
		return
	}
	err = en.WriteFloat64(z.BaseVolume)
	if err != nil {
		err = msgp.WrapError(err, "BaseVolume")
		return
	}
	err = en.WriteFloat64(z.QuoteVolume)
	if err != nil {
		err = msgp.WrapError(err, "QuoteVolume")
		return
	}
	err = en.WriteInt64(z.OpenTime)
	if err != nil {
		err = msgp.WrapError(err, "OpenTime")
		return
	}
	err = en.WriteInt64(z.CloseTime)
	if err != nil {
		err = msgp.WrapError(err, "CloseTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BaseTickData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 15
	o = append(o, 0x9f)
	o = msgp.AppendFloat64(o, z.PriceChange)
	o = msgp.AppendFloat64(o, z.PriceChangePercent)
	o = msgp.AppendFloat64(o, z.LastPrice)
	o = msgp.AppendFloat64(o, z.CloseQty)
	o = msgp.AppendFloat64(o, z.BidPrice)
	o = msgp.AppendFloat64(o, z.BidQty)
	o = msgp.AppendFloat64(o, z.AskPrice)
	o = msgp.AppendFloat64(o, z.AskQty)
	o = msgp.AppendFloat64(o, z.OpenPrice)
	o = msgp.AppendFloat64(o, z.HighPrice)
	o = msgp.AppendFloat64(o, z.LowPrice)
	o = msgp.AppendFloat64(o, z.BaseVolume)
	o = msgp.AppendFloat64(o, z.QuoteVolume)
	o = msgp.AppendInt64(o, z.OpenTime)
	o = msgp.AppendInt64(o, z.CloseTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BaseTickData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 15 {
		err = msgp.ArrayError{Wanted: 15, Got: zb0001}
		return
	}
	z.PriceChange, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "PriceChange")
		return
	}
	z.PriceChangePercent, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "PriceChangePercent")
		return
	}
	z.LastPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "LastPrice")
		return
	}
	z.CloseQty, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CloseQty")
		return
	}
	z.BidPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BidPrice")
		return
	}
	z.BidQty, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BidQty")
		return
	}
	z.AskPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AskPrice")
		return
	}
	z.AskQty, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AskQty")
		return
	}
	z.OpenPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "OpenPrice")
		return
	}
	z.HighPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "HighPrice")
		return
	}
	z.LowPrice, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "LowPrice")
		return
	}
	z.BaseVolume, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BaseVolume")
		return
	}
	z.QuoteVolume, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "QuoteVolume")
		return
	}
	z.OpenTime, bts, err = msgp.ReadInt64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "OpenTime")
		return
	}
	z.CloseTime, bts, err = msgp.ReadInt64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CloseTime")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BaseTickData) Msgsize() (s int) {
	s = 1 + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.Int64Size + msgp.Int64Size
	return
}
